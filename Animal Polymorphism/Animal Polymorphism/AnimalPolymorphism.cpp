// AnimalPolymorphism.cpp: 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include "Animal.h"

int main()
{
	cBird *bird = new cBird;
	cDog *dog = new cDog;
	cSnake *snake = new cSnake;

	cAnimal *animal[3] = { bird,dog,snake };  // 申请一个有三个元素的指针数组，数组里的每一个元素指向 一个子类
	
	for (int index = 0; index < sizeof(animal) / sizeof(animal[0]); index++)
	{
		// 多态: 用父类指针变量 保存子类对象 的地址，再用父类指针 调用虚函数
		animal[index]->walk();   // 通过父类 来遍历 每一个子类的 walk（） 函数
	}
	delete bird;
	delete dog;
	delete snake;
	cout << "\n";
	cBird* bird2 = new cBird;
	cAnimal* pAnimal = bird2;
	pAnimal->walk();
	delete pAnimal;   
	// 这里只释放了父类对象，而子类的没有被释放，想要通过父类来释放子类，需把父类的析构函数定义为虚函数

/*
			动态绑定 和 静态绑定 是相对于函数而言的
	静态绑定：在编译阶段确定调用函数的绑定 称为静态绑定 （在对象中，普通成员函数是不占内存的，而成员变量是占内存的）
				（通过类来调用）

	普通成员函数被存储在的另一片空间里，不需通过对象也可以调用（即使对象没有被真正构造出来） cpeople* people = NULL; people->p_eat(); 是可以的

		普通成员函数是通过 调用者的类型 来调用的，如果一个子类的对象被父类所指向，用父类来调用成员函数，只会调用到父类里的成员函数，要想调用子类里的，
		就需要把父类里 那个与子类相同函数名 的成员函数 在函数类型前 加上 virtual 使之成为 虚函数，就可以实现多态

		拥有虚函数的类 的每一个子类与这个父类相同函数名 都能被父类所调用 （有虚函数的类 仅对 它的子类有效）

	动态绑定：在运行时确定调用函数的绑定称为动态绑定 （通过类里虚函数表 保存的地址来调用）

	一个类里如果定义成了虚函数，那么在这个类的对象里 会有一个专门用来 存虚函数的指针( _vfptr )，这个指针指向的另一片空间，一片专门存储虚函数地址的空间

	虚函数是占内存的  也就是 声明虚函数后，被调用时，不是在普通成员函数那片内存里被调用，而是在 存虚函数的那片内存里来调用 被声明虚函数的类里 会有一个 
	隐藏的指向虚函数表(存储虚函数的内存)的指针( _vfptr ) 成员 （调试可见）

	多态： 相同的 自定义的 数据类型的指针(或引用) 有不同的形态 （用同一个类的指针来调用同一个函数，有着不一样的实现）

	多态的应用: 用父类指针变量 保存子类对象 的地址，再用父类指针 调用虚函数
在实现多态时，防止删除一个 new 出来的子类对象时 未调用子类的析构函数
	（因为应用多态时，是使用父类来调用子类的函数，操作完成后，想要释放父类以及子类的内存时，通过父类来释放
	需要把父类的析构函数 定义为虚函数，才能释放所有的类对象，否则只能释放父类的对象）

	纯虚函数: 没有函数体的虚函数  (定义方式： virtual void walk() = 0; )
	有纯虚函数的类称为抽象类，抽象类不能被实例化 (不能创建对象)
	纯虚函数的作用: 制定一种规则，让它的子类必须去实现它的纯虚函数
*/
	system("pause");
	return 0;
}

